# Fleet Update Status Monitoring
# This workflow monitors update status across all Azure Local clusters and generates reports
#
# USE CASES:
# - Daily/weekly health checks on cluster update status
# - Executive dashboards showing fleet-wide update adoption
# - Alerting when clusters have update failures
# - Compliance tracking for update deployments
#
# REPORTS GENERATED:
# - JUnit XML: Shows each cluster as a test case (passed/failed/skipped) for CI/CD visualization
# - CSV: Detailed export for spreadsheet analysis
# - JSON: Machine-readable format for custom integrations
#
# AUTHENTICATION:
# Uses OpenID Connect (OIDC) - recommended for secretless authentication
# See: https://learn.microsoft.com/en-us/azure/developer/github/connect-from-azure-openid-connect

name: Fleet Update Status

on:
  # Run on schedule (e.g., daily at 6 AM UTC)
  schedule:
    - cron: '0 6 * * *'  # Daily at 6:00 AM UTC
  
  # Manual trigger with options
  workflow_dispatch:
    inputs:
      scope:
        description: 'Scope of clusters to check'
        required: true
        default: 'all'
        type: choice
        options:
          - 'all'              # All clusters across all subscriptions
          - 'by-update-ring'   # Filter by UpdateRing tag
      update_ring:
        description: 'UpdateRing tag value (only used when scope=by-update-ring)'
        required: false
        default: ''
      include_update_runs:
        description: 'Include recent update run history in report'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  MODULE_PATH: './AzStackHci.ManageUpdates'

jobs:
  fleet-status:
    name: Collect Fleet Update Status
    runs-on: windows-latest
    permissions:
      id-token: write
      contents: read
      checks: write  # Required for test reporter
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    # OIDC Authentication - recommended
    - name: Azure CLI Login (OIDC)
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    
    - name: Install Azure CLI Resource Graph Extension
      shell: pwsh
      run: |
        az extension add --name resource-graph --yes
    
    - name: Collect Fleet Update Status
      shell: pwsh
      id: fleet-status
      run: |
        Import-Module "${{ env.MODULE_PATH }}/AzStackHci.ManageUpdates.psd1" -Force
        
        # Create output directory
        $outputDir = "./reports"
        New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
        
        $scope = "${{ github.event.inputs.scope || 'all' }}"
        $updateRing = "${{ github.event.inputs.update_ring }}"
        $includeRuns = "${{ github.event.inputs.include_update_runs || 'true' }}" -eq 'true'
        
        Write-Host "========================================" -ForegroundColor Cyan
        Write-Host "Fleet Update Status Collection" -ForegroundColor Cyan
        Write-Host "========================================" -ForegroundColor Cyan
        Write-Host "Scope: $scope"
        if ($updateRing) { Write-Host "UpdateRing Filter: $updateRing" }
        Write-Host "Include Update Runs: $includeRuns"
        Write-Host ""
        
        # Step 1: Get cluster inventory to find all clusters
        Write-Host "Step 1: Getting cluster inventory..." -ForegroundColor Yellow
        
        $inventoryCsv = Join-Path $outputDir "cluster-inventory.csv"
        $inventory = Get-AzureLocalClusterInventory -ExportPath $inventoryCsv -PassThru
        
        if (-not $inventory -or $inventory.Count -eq 0) {
            Write-Warning "No clusters found in inventory"
            exit 0
        }
        
        Write-Host "Found $($inventory.Count) total cluster(s)" -ForegroundColor Green
        
        # Step 2: Get readiness status for targeted clusters
        Write-Host ""
        Write-Host "Step 2: Checking update readiness..." -ForegroundColor Yellow
        
        $readinessParams = @{}
        
        if ($scope -eq 'by-update-ring' -and $updateRing) {
            $readinessParams['ScopeByUpdateRingTag'] = $true
            $readinessParams['UpdateRingValue'] = $updateRing
        }
        else {
            # Get all cluster resource IDs from inventory
            $resourceIds = $inventory | Select-Object -ExpandProperty ResourceId
            $readinessParams['ClusterResourceIds'] = $resourceIds
        }
        
        # Export to multiple formats
        $readinessCsv = Join-Path $outputDir "readiness-status.csv"
        $readinessJson = Join-Path $outputDir "readiness-status.json"
        $readinessXml = Join-Path $outputDir "readiness-status.xml"
        
        $readiness = Get-AzureLocalClusterUpdateReadiness @readinessParams -ExportPath $readinessCsv
        
        # Also export to JSON
        $readinessExport = @{
            Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC"
            TotalClusters = $readiness.Count
            Summary = @{
                Ready = ($readiness | Where-Object { $_.ReadyForUpdate -eq $true }).Count
                InProgress = ($readiness | Where-Object { $_.UpdateState -eq "UpdateInProgress" }).Count
                HealthFailures = ($readiness | Where-Object { $_.HealthState -eq "Failure" }).Count
                NotReady = ($readiness | Where-Object { $_.ReadyForUpdate -ne $true -and $_.UpdateState -ne "UpdateInProgress" }).Count
            }
            Clusters = $readiness
        }
        $readinessExport | ConvertTo-Json -Depth 10 | Out-File $readinessJson -Encoding UTF8
        
        # Step 3: Generate JUnit XML for CI/CD visualization
        Write-Host ""
        Write-Host "Step 3: Generating JUnit XML report..." -ForegroundColor Yellow
        
        # Build JUnit XML manually for more control over test case details
        $timestamp = Get-Date -Format "yyyy-MM-ddTHH:mm:ss"
        $totalTests = $readiness.Count
        $failures = @($readiness | Where-Object { $_.HealthState -eq "Failure" -or $_.UpdateState -eq "Failed" }).Count
        $inProgress = @($readiness | Where-Object { $_.UpdateState -eq "UpdateInProgress" }).Count
        $ready = @($readiness | Where-Object { $_.ReadyForUpdate -eq $true }).Count
        $upToDate = @($readiness | Where-Object { $_.UpdateState -eq "UpToDate" }).Count
        
        # Build XML using string concatenation (avoids YAML parser issues with here-strings)
        $xmlContent = '<?xml version="1.0" encoding="UTF-8"?>' + "`n"
        $xmlContent += '<testsuites>' + "`n"
        $xmlContent += "  <testsuite name=`"AzureLocalFleetUpdateStatus`" tests=`"$totalTests`" failures=`"$failures`" errors=`"0`" skipped=`"0`" time=`"0`" timestamp=`"$timestamp`">" + "`n"
        $xmlContent += '    <properties>' + "`n"
        $xmlContent += "      <property name=`"scope`" value=`"$scope`"/>" + "`n"
        $xmlContent += "      <property name=`"updateRing`" value=`"$updateRing`"/>" + "`n"
        $xmlContent += "      <property name=`"totalClusters`" value=`"$totalTests`"/>" + "`n"
        $xmlContent += "      <property name=`"readyForUpdate`" value=`"$ready`"/>" + "`n"
        $xmlContent += "      <property name=`"updateInProgress`" value=`"$inProgress`"/>" + "`n"
        $xmlContent += "      <property name=`"upToDate`" value=`"$upToDate`"/>" + "`n"
        $xmlContent += "      <property name=`"healthFailures`" value=`"$failures`"/>" + "`n"
        $xmlContent += '    </properties>' + "`n"
        
        foreach ($cluster in $readiness) {
            $clusterName = $cluster.ClusterName -replace '&', '&amp;' -replace '<', '&lt;' -replace '>', '&gt;'
            $testName = "UpdateStatus-$clusterName"
            $className = "AzureLocalFleetUpdateStatus.$($cluster.ResourceGroup)"
            
            # Determine test outcome
            $status = "passed"
            $failureMessage = ""
            
            if ($cluster.HealthState -eq "Failure" -or $cluster.UpdateState -eq "Failed") {
                $status = "failed"
                $failureMessage = "Health: $($cluster.HealthState), UpdateState: $($cluster.UpdateState)"
                if ($cluster.HealthCheckFailures) {
                    $failureMessage += ", Issues: $($cluster.HealthCheckFailures -replace '&', '&amp;' -replace '<', '&lt;' -replace '>', '&gt;')"
                }
            }
            
            # Build system-out with cluster details (using string concat to avoid YAML parser issues)
            $systemOut = "Cluster: $($cluster.ClusterName)`n"
            $systemOut += "Resource Group: $($cluster.ResourceGroup)`n"
            $systemOut += "Subscription: $($cluster.SubscriptionId)`n"
            $systemOut += "Update State: $($cluster.UpdateState)`n"
            $systemOut += "Health State: $($cluster.HealthState)`n"
            $systemOut += "Ready for Update: $($cluster.ReadyForUpdate)`n"
            $systemOut += "Available Updates: $($cluster.AvailableUpdates)`n"
            $systemOut += "Ready Updates: $($cluster.ReadyUpdates)`n"
            $systemOut += "Recommended Update: $($cluster.RecommendedUpdate)"
            $systemOut = $systemOut -replace '&', '&amp;' -replace '<', '&lt;' -replace '>', '&gt;'
            
            $xmlContent += "`n    <testcase name=`"$testName`" classname=`"$className`" time=`"0`">`n"
            $xmlContent += "      <system-out><![CDATA[$systemOut]]></system-out>`n"
            
            if ($status -eq "failed") {
                $xmlContent += "      <failure message=`"Cluster has update issues`" type=`"UpdateFailure`">$failureMessage</failure>`n"
            }
            
            $xmlContent += "    </testcase>`n"
        }
        
        $xmlContent += "  </testsuite>`n"
        $xmlContent += "</testsuites>`n"
        
        $xmlContent | Out-File $readinessXml -Encoding UTF8
        Write-Host "JUnit XML saved to: $readinessXml" -ForegroundColor Green
        
        # Step 4: Collect additional fleet data using v0.5.6 fleet-wide capabilities
        
        # Step 4a: Get update summary across fleet
        Write-Host ""
        Write-Host "Step 4a: Collecting fleet update summaries..." -ForegroundColor Yellow
        
        $summaryCsv = Join-Path $outputDir "update-summaries.csv"
        $summaryParams = @{ ExportPath = $summaryCsv }
        
        if ($scope -eq 'by-update-ring' -and $updateRing) {
            $summaryParams['ScopeByUpdateRingTag'] = $true
            $summaryParams['UpdateRingValue'] = $updateRing
        }
        else {
            $resourceIds = $inventory | Select-Object -ExpandProperty ResourceId
            $summaryParams['ClusterResourceIds'] = $resourceIds
        }
        
        $summaries = Get-AzureLocalUpdateSummary @summaryParams
        Write-Host "Update summaries collected for $($summaries.Count) cluster(s)" -ForegroundColor Green
        
        # Step 4b: Get available updates across fleet
        Write-Host ""
        Write-Host "Step 4b: Collecting available updates..." -ForegroundColor Yellow
        
        $availableCsv = Join-Path $outputDir "available-updates.csv"
        $availableParams = @{ ExportPath = $availableCsv }
        
        if ($scope -eq 'by-update-ring' -and $updateRing) {
            $availableParams['ScopeByUpdateRingTag'] = $true
            $availableParams['UpdateRingValue'] = $updateRing
        }
        else {
            $resourceIds = $inventory | Select-Object -ExpandProperty ResourceId
            $availableParams['ClusterResourceIds'] = $resourceIds
        }
        
        $available = Get-AzureLocalAvailableUpdates @availableParams
        Write-Host "Found $($available.Count) available update(s) across fleet" -ForegroundColor Green
        
        # Step 4c: Optionally collect recent update runs using fleet-wide query
        if ($includeRuns) {
            Write-Host ""
            Write-Host "Step 4c: Collecting recent update run history..." -ForegroundColor Yellow
            
            $runsCsv = Join-Path $outputDir "update-runs.csv"
            $runsParams = @{ Latest = $true; ExportPath = $runsCsv }
            
            if ($scope -eq 'by-update-ring' -and $updateRing) {
                $runsParams['ScopeByUpdateRingTag'] = $true
                $runsParams['UpdateRingValue'] = $updateRing
            }
            else {
                # Use cluster names from inventory for fleet-wide query
                $clusterNames = $inventory | ForEach-Object { $_.ClusterName }
                $runsParams['ClusterNames'] = $clusterNames
            }
            
            $allRuns = Get-AzureLocalUpdateRuns @runsParams
            Write-Host "Update runs collected for $($allRuns.Count) cluster(s)" -ForegroundColor Green
            
            # Display summary
            $succeeded = @($allRuns | Where-Object { $_.State -eq 'Succeeded' }).Count
            $inProgressRuns = @($allRuns | Where-Object { $_.State -eq 'InProgress' }).Count
            $failedRuns = @($allRuns | Where-Object { $_.State -eq 'Failed' }).Count
            Write-Host "  Succeeded: $succeeded, In Progress: $inProgressRuns, Failed: $failedRuns"
        }
        
        # Step 5: Output summary
        Write-Host ""
        Write-Host "========================================" -ForegroundColor Cyan
        Write-Host "Fleet Status Summary" -ForegroundColor Cyan
        Write-Host "========================================" -ForegroundColor Cyan
        Write-Host "Total Clusters: $totalTests"
        Write-Host "Up to Date: $upToDate" -ForegroundColor Green
        Write-Host "Update In Progress: $inProgress" -ForegroundColor Yellow
        Write-Host "Ready for Update: $ready" -ForegroundColor Cyan
        Write-Host "Health Failures: $failures" -ForegroundColor $(if ($failures -gt 0) { "Red" } else { "Green" })
        
        # Set output variables for downstream steps
        echo "TOTAL_CLUSTERS=$totalTests" >> $env:GITHUB_OUTPUT
        echo "UP_TO_DATE=$upToDate" >> $env:GITHUB_OUTPUT
        echo "IN_PROGRESS=$inProgress" >> $env:GITHUB_OUTPUT
        echo "READY=$ready" >> $env:GITHUB_OUTPUT
        echo "FAILURES=$failures" >> $env:GITHUB_OUTPUT
        
        # Fail the workflow if there are health failures
        if ($failures -gt 0) {
            Write-Host ""
            Write-Warning "‚ö†Ô∏è $failures cluster(s) have update failures or health issues!"
            Write-Host "Check the detailed reports for more information."
            # Note: We don't exit 1 here to allow reports to be uploaded
        }
    
    - name: Upload Fleet Status Reports
      uses: actions/upload-artifact@v4
      with:
        name: fleet-status-reports
        path: ./reports/
        retention-days: 90
    
    # Publish JUnit test results for visualization in GitHub Actions
    - name: Publish Test Results
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: Fleet Update Status Report
        path: ./reports/readiness-status.xml
        reporter: java-junit
        fail-on-error: false  # Don't fail the action on test failures
    
    - name: Create Status Summary
      if: always()
      shell: pwsh
      run: |
        $total = "${{ steps.fleet-status.outputs.TOTAL_CLUSTERS }}"
        $upToDate = "${{ steps.fleet-status.outputs.UP_TO_DATE }}"
        $inProgress = "${{ steps.fleet-status.outputs.IN_PROGRESS }}"
        $ready = "${{ steps.fleet-status.outputs.READY }}"
        $failures = "${{ steps.fleet-status.outputs.FAILURES }}"
        
        $summary = @"
        ## üìä Fleet Update Status Summary
        
        | Metric | Count | Status |
        |--------|-------|--------|
        | **Total Clusters** | $total | ‚ÑπÔ∏è |
        | **Up to Date** | $upToDate | ‚úÖ |
        | **Update In Progress** | $inProgress | üîÑ |
        | **Ready for Update** | $ready | üì• |
        | **Health Failures** | $failures | $(if ([int]$failures -gt 0) { '‚ùå' } else { '‚úÖ' }) |
        
        ### Reports Available
        - üìÑ `readiness-status.csv` - Detailed cluster status for spreadsheet analysis
        - üìÑ `readiness-status.json` - Machine-readable format for integrations
        - üìÑ `readiness-status.xml` - JUnit XML for CI/CD visualization
        - üìÑ `cluster-inventory.csv` - Full cluster inventory
        - üìÑ `update-summaries.csv` - Fleet-wide update state summaries
        - üìÑ `available-updates.csv` - All available updates across fleet
        - üìÑ `update-runs.csv` - Recent update run history (if enabled)
        
        *Generated at $(Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC")*
        "@
        
        $summary | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
